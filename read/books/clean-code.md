--- 
title: "《代码整洁之道》"
date: 2025-06-28T18:12:40+08:00
lastmod: 2025-06-28T18:12:40+08:00
author: ["熊大如如"]
tags: # 标签
  - "clean code"
description: ""
weight:
slug: ""
summary: "《代码整洁之道》"
draft: false # 是否为草稿
mermaid: true #是否开启mermaid
showToc: true # 显示目录
TocOpen: true # 自动展开目录
hidemeta: false # 是否隐藏文章的元信息，如发布日期、作者等
disableShare: true # 底部不显示分享栏
showbreadcrumbs: true #顶部显示路径
cover:
  image: "https://cdn.jsdelivr.net/gh/xxrBear/image/Hugo/202506291327289.jpg"  # 文章的图片

---

## 一本计算机经典书籍

《代码整洁之道》(Clean Code)可以说是软件开发领域最有影响力的书籍之一了，在全球开发者之中都享有盛名。这本书的作者 Robert C.
Martin，人称"鲍勃大叔"，他是敏捷开发和软件工匠精神的早期倡导者之一。是一个有几十年软件开发经验，软件开发领域的“老一辈实战派”。他还是
SOLID 五大面向对象设计原则的提出者之一，这些原则后来成为很多系统架构和设计课程的核心内容。

读完本书后，我对很多观点深感认同。比如第一章《整洁代码》里提到，混乱的代码是许多项目失败的原因，代码之间互相交错，不停叠加新功能，导致代码的可读性越来越差，这些因素直接导致了代码不可维护，最终导致项目失败，他提到的童子军军规让人印象深刻：

> “让营地比你来时更干净”

这句话形象地表达了作者对代码持续整洁的追求：每一次提交代码，都应让系统变得更好，而不是更差。

第二章《有意义的命名》中说他提到，命名应该名副其实，避免误导，一旦想到更有意义的命名，那么就果断替换掉旧有的名字。

关于函数设计，作者主张函数应尽量简短，参数越少越好，最好没有。这样可以减少理解成本，提高可维护性。
对于注释，他的观点是：注释必须准确，错误的注释比没有更糟糕，因为它会误导读者。注释和代码一样需要持续维护，否则它们也会“腐烂生锈”，最终损害整个项目。
此外，作者认为统一的代码风格至关重要。软件开发是多人协作的过程，一个项目应以人为本，制定并遵循统一的编码规范，这样才能减少沟通成本，提高整体效率。

## 为什么越来越多的人反对 Clean Code

《Clean Code》（干净代码）是软件开发中的经典理念，强调代码的可读性、可维护性和简洁性。尽管它有诸多优点，但是近些年来，业界反对Clean
Code的声音也越来越多，越来越大，我搜集总结了如下：

**1.过度追求“干净”可能导致过度设计**

为了满足“单一职责”或“短函数”等原则，代码可能被拆分成过多的小函数或类，导致碎片化，反而增加跳转和理解成本

**2.忽视性能问题**

- Clean Code 强调可读性，但有时会牺牲性能。例如：
    - 频繁的小函数调用可能增加栈开销
    - 避免重复代码可能导致运行时动态派发（如多态）的性能损耗
- 适用场景受限：在高性能计算或嵌入式开发中，可能需要对代码进行针对性优化，而“干净”的抽象可能成为障碍

**3.教条主义风险**

- 盲目遵循规则：将 Clean Code 视为绝对真理，忽视实际需求。例如：
    - 硬性要求函数不超过 10 行，可能破坏逻辑的连贯性
    - 过度重命名变量（如 `x` 改为 `userInputValue`）可能导致冗长
- 忽视团队差异：不同团队对“干净”的定义可能不同，严格统一标准可能引发争议

还有人认为，《Clean Code》内容重复、篇幅冗长，尤其是案例分析部分显得主观，有时甚至像是在“推销作者自己的编码风格”，比如：

* 函数或类过度拆分，可能导致维护成本上升
* TDD（测试驱动开发）在紧急项目中难以推行
* 实际项目中，我们往往需要在“优雅”与“性能”、“进度”之间权衡取舍

**4.维护成本可能不降反升**

- 频繁重构：为了追求“干净”，开发者可能花费大量时间重构已有代码，而忽略实际功能交付
- 历史代码兼容性：在遗留系统中强行应用 Clean Code 原则可能破坏现有逻辑，引入新 Bug

**5.忽略领域复杂性**

- 某些复杂业务逻辑（如数学算法、状态机）可能需要较长的函数或复杂结构，强行拆分反而难以理解
- 可读性≠易理解：代码形式上的“干净”并不保证业务逻辑的清晰性，尤其是对领域新手

**6.可能掩盖设计缺陷**

- 表面“干净”的代码可能通过复杂的抽象层隐藏设计问题（如错误的职责划分），反而让问题更难被发现

**7.时间成本**

编写“干净”代码通常需要更多时间，在快速迭代或原型开发阶段可能不划算，我们要面对技术债、紧张的工期、团队协作问题以及大量历史遗留代码。现实中的代码，很难始终保持“完美整洁”。

> 我们不是在写诗，我们是在交付产品

## 我们该如何看待《Clean Code》？

《Clean Code》无疑是一本影响深远的经典著作，它强调代码的整洁性、可读性与可维护性，为程序员提供了清晰的规范和实践指南。

但在实际工作中，我们必须理性看待这本书，意识到它强调的是“理想”，而非“现实”。

Clean Code 更像是“个人主义编码风格指南”，很少关注实际开发中更重要的因素，比如：

* 业务价值优先
* 团队协作与知识共享
* 系统设计与架构的边界划分

在真实项目里，你很快就会发现：

* 模块之间如何协作，比函数名是否足够优雅更重要
* 即使代码非常“整洁”，如果系统设计混乱，整个项目依然脆弱不堪

一句话总结就是：

> Clean Code 忽略了软件工程的最大现实要求：一切都是权衡

Uncle Bob 的背景是早期 Java/C++ 大型系统开发，那时的代码维护困难、工具落后，所以强调极度模块化是合理的

而今天的开发环境已经发生了巨大变化：

| 过去         | 现在               |
| ------------ | ------------------ |
| 类动辄几百行 | 类趋向轻量         |
| IDE 功能弱   | 自动重构、跳转定义 |
| 单体服务常见 | 微服务、模块化     |
| 测试工具初期 | CI/CD 流程完备     |

现代语言（如Go、Rust）更表达式化、简洁，很多 Clean Code 的实践看起来反而是“过度设计”

常见“照搬 Clean Code”后的反效果：

* 类太多：每个逻辑抽象成一个类，层层包裹
* 函数太碎：每五行一个函数，阅读连贯性差
* 接口泛滥：过度抽象，导致概念稀释

虽然Clean Code在现代开发环境下显的有点古板，然而他确实做到了：

* 帮助初学者建立“代码质量”的基本认知
* 推动整洁、可读、可维护的编码理念传播
* 是“软件工匠精神”的代表作
* 提供了大量具体、可操作的实践（尽管部分有争议）

**总结**

Clean Code 值得一读，但不必奉为圭臬。它不是编程的“圣经”，而更像一本风格训练手册：

- 对于初学者，它是打开“代码整洁世界”的一扇门；
- 对于有经验的开发者，它是一个值得参考的坐标系；
- 对于实际项目，最重要的不是照搬规则，而是在团队、语言、业务之间找到最适合的平衡点。

写“整洁代码”的终极目的，是让团队更容易理解、维护和演进系统，而不是自我感动。